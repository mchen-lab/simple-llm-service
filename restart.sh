# ===== AUTO-GENERATED BY APP-KIT - DO NOT EDIT =====
# This file is managed by @mchen-lab/app-kit and will be
# overwritten when running `npx @mchen-lab/app-kit update`.
# Version: 0.1.12
# ====================================================

#!/bin/bash

# Get the absolute path of the project root
PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# ============================================================================
# CONFIGURATION (populated from devops.config.json)
# ============================================================================
# All ports to kill on restart
KILL_PORTS="31160 31161"

# Allowed process names to kill (regex pattern for matching)
ALLOWED_PROCESSES="node|python"

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

# Check if node_modules exists (dependencies installed)
if [ ! -d "$PROJECT_ROOT/node_modules" ]; then
    echo "โ Error: node_modules not found. Please run 'npm install' from the root directory first."
    exit 1
fi

# Function to backup existing log file
backup_log() {
    local log_file=$1
    local log_name=$2

    if [ -f "$log_file" ]; then
        if [ -f "${log_file}.bak" ]; then
            echo "Overwriting existing $log_name backup and creating new backup: ${log_file}.bak"
        else
            echo "Backing up existing $log_name log to ${log_file}.bak"
        fi
        mv "$log_file" "${log_file}.bak"
    fi
}

# Function to kill process on a specific port
# Only kills processes matching ALLOWED_PROCESSES pattern
kill_port() {
    local port=$1
    local process_name=$2

    echo "Checking for existing $process_name processes on port $port..."
    
    # use lsof to get PIDs - only target the listener to avoid conflicts with persistent client connections (e.g. Chrome)
    local pids=$(lsof -ti :$port -sTCP:LISTEN 2>/dev/null)
    
    if [ ! -z "$pids" ]; then
        # Iterate through PIDs to check their command name
        local target_pids=""
        for pid in $pids; do
            # Get the command name for the PID
            local cmd=$(ps -p $pid -o comm= 2>/dev/null)
            # Check if command matches allowed processes (basename)
            local cmd_base=$(basename "$cmd" 2>/dev/null)
            
            # Check if process is in the allowed list using regex pattern
            if [[ "$cmd_base" =~ ^($ALLOWED_PROCESSES)$ ]]; then
                target_pids="$target_pids $pid"
            else
                echo "โ๏ธ  Warning: Process '$cmd' (PID: $pid) is using port $port. NOT killing it as it does not appear to be our server."
                echo "   maybe a docker version is already running"
                return 1
            fi
        done

        if [ ! -z "$target_pids" ]; then
            echo "Found existing process(es) (PIDs:$target_pids). Killing..."
            echo "$target_pids" | xargs kill -9 2>/dev/null || true
            sleep 2
            
            # Verify they are killed
            local remaining_pids=$(lsof -ti :$port -sTCP:LISTEN 2>/dev/null)
            if [ ! -z "$remaining_pids" ]; then
                echo "โ๏ธ  Warning: Port $port may still be in use."
            else
                echo "โ Successfully killed processes on port $port."
            fi
        fi
    else
        # Fallback checks only if port was empty
        echo "No process found directly binding port $port."
        
        # We can keep the specific pattern matches as a secondary cleanup sweep
        # just in case the port wasn't bound yet but the process exists
        local cleanup_pids=""
        cleanup_pids=$(pgrep -f "workspace=$process_name" 2>/dev/null || true)
        
        if [ ! -z "$cleanup_pids" ]; then
             echo "Cleaning up loose workspace processes: $cleanup_pids"
             echo "$cleanup_pids" | xargs kill -9 2>/dev/null || true
        fi
    fi
}

# Function to kill all configured ports
kill_all_ports() {
    local abort_on_failure=${1:-false}
    
    for port in $KILL_PORTS; do
        if ! kill_port $port "server"; then
            if [ "$abort_on_failure" = "true" ]; then
                return 1
            fi
        fi
    done
    return 0
}

start_server() {
    echo "๐ Starting simple-llm-service on port 31160..."

    # Ensure logs/servers directory exists
    mkdir -p "$PROJECT_ROOT/logs"

    # Backup existing server log
    backup_log "$PROJECT_ROOT/logs/server.log" "server"

    # Start server with watch mode enabled
    cd "$PROJECT_ROOT"
    # Use native Node watch mode with tsx for TypeScript support
    # --watch-path src ensures we ONLY restart when source code changes
    node --import tsx --watch --watch-path src src/server/index.ts >> "$PROJECT_ROOT/logs/server.log" 2>&1 &
    SERVER_PID=$!
    echo "โ Server started with PID: $SERVER_PID"
    echo "๐ Server logs: $PROJECT_ROOT/logs/server.log"
}

# Trap function to kill processes
cleanup() {
    echo ""
    echo "Cleaning up..."
    if [ ! -z "$TAIL_PID" ]; then
        kill $TAIL_PID 2>/dev/null
    fi
    if [ ! -z "$SERVER_PID" ]; then
        echo "Killing server process $SERVER_PID"
        kill $SERVER_PID 2>/dev/null
    fi
    # Also attempt to kill by port as a fallback
    kill_all_ports
    exit 0
}

trap cleanup INT TERM EXIT

echo "๐ Stopping any existing simple-llm-service server..."
if ! kill_all_ports "true"; then
    echo "โ restart aborted."
    exit 1
fi

echo ""
echo "๐งน Cleaning previous build artifacts..."
if [ -d "$PROJECT_ROOT/dist" ]; then
    echo "   Removing dist directory to force dev mode..."
    rm -rf "$PROJECT_ROOT/dist"
    echo "   โ Cleaned dist"
fi

echo "๐ฏ Starting simple-llm-service..."
echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
start_server

echo ""
echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"
echo "โ simple-llm-service is running!"
echo ""
echo "๐ Services:"
echo "   โข Web UI & API: http://localhost:31160"
echo ""
echo "Press Ctrl+C to stop"
echo "โโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโโ"

# Tail the logs to keep the script running and show output
echo "๐ Tailing logs (Ctrl+C to stop)..."
tail -f "$PROJECT_ROOT/logs/server.log" &
TAIL_PID=$!

wait $TAIL_PID
